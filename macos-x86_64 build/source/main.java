/* autogenerated by Processing revision 1293 on 2024-05-11 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.awt.*;
import java.io.*;
import java.util.*;
import javax.swing.*;
import ddf.minim.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class main extends PApplet {



 


DisplayFrame sa;
PopoutMenu outputSelectMenu;

PVector default_scale = new PVector(900, 1400);
PImage volIcon;

PFont default_font;
String[] font_tester;
//highest unicode codepoint is 289460
int highest_codepoint = 289460;
FontController font_controls = new FontController(0, highest_codepoint, 900-55, 120, 40);

Transcript trans;
Boolean is_transcript;
File track, transcript, outputDirectory;
String outputExtention = "";

//colour scheme of the whole program
int background_colour = color(76, 56, 76);
int ui_background = color(11, 57, 84);
int ui_active = color(232, 232, 232);
int ui_highlight = color(129, 198, 239);
int error_colour = color(252, 129, 74);
int[] buttonCols = {ui_background, ui_highlight, ui_active, error_colour};
int[] sliderCols = {ui_active, ui_highlight};
int[] menuCols = {ui_background, error_colour};

//num of millis to skip when fastforward or reversing
int skipMillis = 500;

ButtonFunction placeholder_func = () -> println("this is a placeholder function");

ButtonFunction saveTranscript = () -> {
  saveButtonControl();
};

ButtonFunction spawnWindow = () -> {
  if(sa == null){
    String[] args = {"track info"};
    sa = new DisplayFrame();
    runSketch(args, sa);
    removeButton(5);
  }
};

ButtonFunction chooseTrack = () -> {
  is_transcript = false;
  selectInput("Select a track to play:", "chooseFile");
  spawnWindow.execute();
};

ButtonFunction chooseTranscript = () -> {
  is_transcript = true;
  selectInput("Select a transcript to sync:", "chooseFile");
};

ButtonFunction chooseOutputDir = () -> {
  selectFolder("Select output directory:", "chooseDirectory");
};

ButtonFunction chooseOutputForm = () -> {
  outputSelectMenu.toggleMenu();
};

ButtonFunction restartButton = () -> {
  if(sa != null){
    sa.restartAudioVideo();
  }
  if(trans != null){
    trans.resetTranscript();
  }
};

ButtonFunction reverseButton = () -> {
  if(sa != null){
    sa.fastforward(-skipMillis*40);
  }
};

ButtonFunction ffButton = () -> {
  if(sa != null){
    sa.fastforward(skipMillis);
  }
};

ButtonFunction pauseButton = () -> {
  if(sa != null){
    sa.playButton();
  }
  setPauseButtonName();
};

SliderFunction timelineSliderSkip = (Slider self, float pos) -> {
  if(sa != null){
    float newPos = self.getPos();
    self.updatePos(newPos);
    sa.setTime(PApplet.parseInt(newPos * sa.getTime()));
  }
};
 
SliderFunction volumeSlider = (Slider self, float pos) -> {
  if(sa != null){  
    sa.setVol(-pos -1);
    println(-pos -1);
  }
};
 
ArrayList<Button> systemControlButtons = new ArrayList<Button>();
  Button save_trans   =      new Button(20,  10, 35,  30, str('\u2193'),          buttonCols, saveTranscript,   true);
  Button select_track =      new Button(65,  10, 75,  30, "track",                buttonCols, chooseTrack,      true);
  Button select_transcript = new Button(150, 10, 135, 30, "transcript",           buttonCols, chooseTranscript, true);
  Button change_output_dir = new Button(295, 10, 235, 30, "output directory",     buttonCols, chooseOutputDir,  true);
  Button change_out_format = new Button(540, 10, 65,  30, "???",                  buttonCols, chooseOutputForm, true);
  Button spawn_window =      new Button(PApplet.parseInt(default_scale.x-55), 10, 35, 30, str('\u23cf'), buttonCols, spawnWindow,      false);
  
ArrayList<Button> trackControlButtons = new ArrayList<Button>();
  Button restart_button = new Button(PApplet.parseInt(default_scale.x-255), 10, 35, 30, str('\u23EE'), buttonCols, restartButton, false);
  Button reverse_button = new Button(PApplet.parseInt(default_scale.x-205), 10, 35, 30, str('\u23EA'), buttonCols, reverseButton, false);
  Button pause_button =   new Button(PApplet.parseInt(default_scale.x-155), 7,  40, 33, "▶",           buttonCols, pauseButton,   false);
  Button ff_button =      new Button(PApplet.parseInt(default_scale.x-105), 10, 35, 30, str('\u23E9'), buttonCols, ffButton,      false);


//lrc, sbv, smi, sami, srt, txt, vtt, [none]
ArrayList<Button> filetypeSelectionButtons = new ArrayList<Button>();
  Button select_lrc = new Button (367, 100, 65, 30, "lrc", buttonCols, placeholder_func, true);
  Button select_sbv = new Button (444, 100, 65, 30, "sbv", buttonCols, placeholder_func, true);
  Button select_smi = new Button (523, 100, 65, 30, "smi", buttonCols, placeholder_func, true);
  
  Button select_sami= new Button (367, 143, 65, 30, "sami", buttonCols, placeholder_func, true);
  Button select_srt = new Button (444, 143, 65, 30, "srt", buttonCols, placeholder_func, true);
  Button select_txt = new Button (523, 143, 65, 30, "txt",buttonCols, placeholder_func, true);
  
  Button select_vtt = new Button (367, 186, 65, 30, "vtt", buttonCols, placeholder_func, true);
  
  Button select_none= new Button (367, 272, 221, 30, "NONE", buttonCols, placeholder_func, true);

ButtonFunction sLRC = () -> updateFSButtons(select_lrc);
ButtonFunction sSRT = () -> updateFSButtons(select_srt);
ButtonFunction sSBV = () -> updateFSButtons(select_sbv);

ButtonFunction sVTT = () -> updateFSButtons(select_vtt);
ButtonFunction sSMI = () -> updateFSButtons(select_smi);
ButtonFunction sSAMI= () -> updateFSButtons(select_sami);

ButtonFunction sTXT = () -> updateFSButtons(select_txt);

ButtonFunction sNONE= () -> updateFSButtons(select_none);

ArrayList<Slider> mediaControlSliders = new ArrayList<Slider>();
  Slider volume   = new Slider(new PVector(PApplet.parseInt(default_scale.x-35), 264), 0, 100, "volume",   .5f, sliderCols, volumeSlider);
  Slider timeline = new Slider(new PVector(PApplet.parseInt(default_scale.x-135), 64), 100, 0, "timeline", .5f, sliderCols, timelineSliderSkip);

public void updateFSButtons(Button thisButton){
  String exten = thisButton.getName();
  
  if(exten.equals("NONE")){
    outputExtention = "";
    change_out_format.setName("N/A");
  } else {
    outputExtention = "." + exten;
    change_out_format.setName(exten);
  }
  filetypeSelectionButtons.forEach((b) -> b.setError(true));
  thisButton.setError(false);
  change_out_format.setError(false);
}

public void removeButton(int i){
  Button blank_button = new Button(-1000, -1000, 4, 4, "", buttonCols, placeholder_func, false);
  systemControlButtons.set(i, blank_button);
}

public void setPauseButtonName(){
  if(sa != null && sa.getIsPlaying()){
    pause_button.setName(str('\u23F8'));
  } else {
    pause_button.setName("▶");
  }
}

public void setDirButtonName(){
  if(outputDirectory != null){
    change_output_dir.setName(outputDirectory.getName());
  }
}

public void saveButtonControl(){
  if(save_trans.getError()){
    return;
  }
  trans.saveTranscript();
}

/*
void settings() {
  size(int(default_scale.x), int(default_scale.y));
}
*/

public void setup(){
  select_lrc.setFunc(sLRC);
  select_srt.setFunc(sSRT);
  select_sbv.setFunc(sSBV);
  
  select_vtt.setFunc(sVTT);
  select_smi.setFunc(sSMI);
  select_sami.setFunc(sSAMI);
  
  select_txt.setFunc(sTXT);
  
  select_none.setFunc(sNONE);
  
  filetypeSelectionButtons.add(select_lrc);
  filetypeSelectionButtons.add(select_srt);
  filetypeSelectionButtons.add(select_sbv);
  
  filetypeSelectionButtons.add(select_vtt);
  filetypeSelectionButtons.add(select_smi);
  filetypeSelectionButtons.add(select_sami);
  
  filetypeSelectionButtons.add(select_txt);
  
  filetypeSelectionButtons.add(select_none);
  
  int scale_adjust = 0;
  PVector filetypeMenuLoc = new PVector(477, 190 + (scale_adjust/2));
  PVector filetypeMenuDim = new PVector(260, 270 + scale_adjust);
  outputSelectMenu = new PopoutMenu("select output format", menuCols, filetypeMenuLoc, filetypeMenuDim, filetypeSelectionButtons); 

  //this is not an existant font, so processing defaults to system fonts for any unicode
  default_font = createFont("getting system fonts - this error is expected", 20);
  textFont(default_font);
  
  //font_controls.getBrokenRanges();
  //font_tester = loadStrings("font_chars_tester.txt");
  trans = new Transcript(new String[] {" "});

  systemControlButtons.add(save_trans);
  systemControlButtons.add(select_track);
  systemControlButtons.add(select_transcript);
  systemControlButtons.add(change_output_dir);
  systemControlButtons.add(change_out_format);
  systemControlButtons.add(spawn_window);
  
  trackControlButtons.add(pause_button);
  trackControlButtons.add(ff_button);
  trackControlButtons.add(reverse_button);
  trackControlButtons.add(restart_button);
  
  mediaControlSliders.add(volume);
  mediaControlSliders.add(timeline);
  
  /* size commented out by preprocessor */;
  surface.setTitle("transcript");
  surface.setResizable(true);
  surface.setLocation(displayWidth/2 - PApplet.parseInt(default_scale.x/1.5f), displayHeight/2 - PApplet.parseInt(default_scale.y/2));
  
  volIcon = loadImage("volume.png");
}

public void draw(){
  background(background_colour);
  defaultDrawing();
  
  //update the transcript on the page, transcript related hotkeys
  //drawn early to avoid overlapping the buttons and controls
  if(trans != null){
    trans.update();
  }

  if(sa != null){
    timeline.updatePos(sa.getTimeMillis() / sa.getTime());
  }
  
  //render core system buttons & implement functionalities
  systemControlButtons.forEach((b) -> b.render());
  trackControlButtons.forEach((t) -> t.render());
  mediaControlSliders.forEach((m) -> m.render());
  outputSelectMenu.renderMenu();

  pushMatrix();
  translate(875, 210);
  textSize(20);
  rotate(radians(90));
  fill(ui_active);
  text("volume", 0, 0);
  popMatrix();

  //display the font tester rolling over every unicode display
  //font_controls.font_stack_tester();
}

//combined func for selecting transcript and track files, yucky because of buttonfunction nonsense
public void chooseFile(File selection) {
  if(selection == null){
    println("no file selected!");
  } else {
    String filename = selection.getName();
    int i = filename.lastIndexOf('.');
    String extention = "";
    
    //get file extention
    if(i == -1){
      println("this file has no extention!");
    } else {
      extention = filename.substring(i+1);
    }
    
    //switch which file is defined based on button press
    if(is_transcript){
      
      transcript = selection;
      select_transcript.setError(false);
      
      if(!change_output_dir.getError()){
        save_trans.setError(false);
      }
      
      if(extention.equals("")){
        change_out_format.setName("N/A");
      } else if (outputExtention.equals("")){
        change_out_format.setName("." + extention);
        outputExtention = "." + extention;
      }
      change_out_format.setError(false);
      
      trans = new Transcript(loadStrings(transcript));

    } else if(extention.equals("mp3") || extention.equals("wav") || extention.equals("snd") || extention.equals("au") || extention.equals("aiff")){        
      track = selection;
      select_track.setError(false);
    } else {
      println("incompatable filetype! Track must be mp3, wav, snd, au, or aiff!");
    }
  }
}

public void chooseDirectory(File selection){
  if(selection == null){
    println("no directory selected!");
  } else {
    outputDirectory = selection;
    setDirButtonName();
    change_output_dir.setError(false);
    
    if(!select_transcript.getError()){
      save_trans.setError(false);
    }
  }
}

// resent default drawing modes
public void defaultDrawing(){
  strokeWeight(3);
  rectMode(CORNER);
}

//input a time in milliseconds, output converted timecode info
//handles format as an array of ints, rather than a string, so that
//place information, leading zeroes and whatnot are preserved
//and is readable at the same time, without gross %f shit
//                         millis   include hours  HH?MM?SS        include hundreths  SS?HHH
public String getFormatedTimecode(int mil, Boolean hours, char delimiter, Boolean hundreths, char fractionals){
  String formatted_timecode = "";
  
  //manipulate non-hundrets by secs/min/hours to deal with rollover @ 60
  int secs = mil/1000; 
  int mins = secs/60;  
  int hrs  = mins/60;
  
  //need to do this for accurate 10s places
  secs = secs-(mins*60); 
  
  //hours
  if(hours){
    //need to do this for conditional formatting for hours inclusion
    mins = mins-(hrs*60);
    
    formatted_timecode += hrs/10 + str(hrs%10) + delimiter; //even handles the event there are >99 hours!
  }
  
  //minutes
  formatted_timecode += mins/10 + str(mins%10) + delimiter; //handles hourless cases with >60 minutes!

  //seconds 
  formatted_timecode += secs/10 + str(secs%10);

  //thousanths, hundreths, and tenths
  //not pre-formatted as secs, mins, & hrs are, hence % / mixing
  if(hundreths){
    formatted_timecode += fractionals + str((mil%1000)/100) + str((mil%100)/10) + mil%10;
  }
  
  return formatted_timecode;
}
@FunctionalInterface
public interface ButtonFunction {
  public void execute(); 
}

public class Button{
  Boolean pressed, errState;
  PVector loc = new PVector();
  PVector dimens = new PVector();
  String text; 
  ButtonFunction func;
  int[] cols = new int[4]; //fill, stroke, click colour, error colour
  
  //in order: x & y of top left corner, width, height, text to display, colour pallete, this button's associated function, if the button starts with an error state
  public Button(int x, int y, int w, int h, String text, int[] cols, ButtonFunction func, Boolean err){
    loc.x = x;
    loc.y = y;
    dimens.x = w;
    dimens.y = h;
    this.text = text;
    this.cols = cols.clone();
    this.func = func;
    pressed = false;
    errState = err;
  }
  
  //draw and animate the button
  public void render(){
    //offset vars controll the 'depress' animation when clicked
    float y_offset = loc.y;
    float height_offset = dimens.y;
    //col vars track how colour pallet inverts based on default, hover, and click
    int stroke_col = cols[1];
    int fill_col = cols[0];
    
    //display error colours
    if(errState == true){
      stroke_col = cols[3];
    }
    
    //hover detection
    if(mouseY > loc.y && mouseY < loc.y+dimens.y && mouseX > loc.x && mouseX < loc.x+dimens.x){
      fill_col = cols[1];
      stroke_col = cols[0];

      //click detection --> triggers if mouse is pressed while hovering over, not just click on the button. need a latch i think to do proper click detection
      if(mousePressed){
        fill_col = cols[2];
        stroke_col = cols[1];
        //depress button
        y_offset += dimens.y/9;
        height_offset -= dimens.y/9;
        
        //flip latch to detect *clicks* not presses
        pressed = true;
      } else {
        run_func();
      }
    }
    
    //draw button
    fill(fill_col);
    stroke(stroke_col);
    rect(loc.x, y_offset, dimens.x, height_offset, 10);
    
    //shift pallette & draw text
    fill(stroke_col);
    stroke(fill_col);
    text_display(y_offset);
  }
  
  //draw text within region, animate accordingly
  public void text_display(float y_offset){
    textSize(dimens.y - dimens.y/9 - 2);
    //will not draw text outside specified region
    textAlign(CENTER);
    text(text, loc.x + dimens.y/8, y_offset + dimens.y/8, dimens.x - dimens.y/8, dimens.y - dimens.y/8);
  }
  
  //run buttonfunctions associated with the button pressed
  public void run_func(){
    if(pressed){
      func.execute();
      pressed = false;
    }
  }
  
  public void setFunc(ButtonFunction funky){
    func = funky;
  }
  
  //setopacity short for "void setopacity float-alpha" would be a beautiful name for a baby girl
  public void setOpacity(float alpha){
    cols[0] = color(red(cols[0]), green(cols[0]), blue(cols[0]), alpha);
    cols[1] = color(red(cols[1]), green(cols[1]), blue(cols[1]), alpha);
    cols[2] = color(red(cols[2]), green(cols[2]), blue(cols[2]), alpha);
    cols[3] = color(red(cols[3]), green(cols[3]), blue(cols[3]), alpha);
  }
  
  //set the error display state
  public void setError(Boolean err){
    errState  = err;
  }
  
  //get the error display state
  public Boolean getError(){
    return errState;
  }
  
  //alter string displayed on button
  public void setName(String newName){
    text = newName;
  }
  
  public String getName(){
    return text;
  }
}
public class FontController{
  int this_codepoint, end_codepoint, scale, restart;
  float x, y;
  char[] chars_uni;
  
  //vars to check & record where the font fails
  ArrayList<Integer> failurePoints = new ArrayList<Integer>();
  Boolean lastFailed = false;
  Boolean failures_latch = false;
  
  public FontController(int start_codepoint, int end_codepoint, float x_pos, float y_pos, int scale){
    this_codepoint = start_codepoint - 1;
    restart = start_codepoint;
    x = x_pos;
    y = y_pos; 
    this.end_codepoint = end_codepoint;
    this.scale = scale;
  }
  
  /* display the rolling unicode icon
     also output the nonfunctional codepoints
  */
  public void font_stack_tester() {
    //loop once at the end of testing range
    if(this_codepoint > end_codepoint){
      this_codepoint = restart;
      
      //let this stop once we've hit every codepoint we care about
      if(!failures_latch){
        println("null codepoints: ");
        for(int i = 0; i < failurePoints.size(); i++){
          if(i%2 == 0){
            print("[" + failurePoints.get(i) + ", ");
          } else {
            print(failurePoints.get(i) + "]\n");
          }
        }
      }
      
      failures_latch = true;
    } else {
      this_codepoint++;
    }
    
    //get the char from the codepoint
    chars_uni = (Character.toChars(this_codepoint));
  
    //does this font display it?
    if (default_font.getGlyph(chars_uni[0]) == null){
      stroke(error_colour);
      fill(error_colour);
      
      //is this the first failure of a region?
      if(!lastFailed){
        failurePoints.add(this_codepoint);
        lastFailed = true;
      }
    } else {
      stroke(ui_highlight);
      fill(ui_highlight);
      
      //is this ending a failed region?
      if(lastFailed){
        failurePoints.add(this_codepoint);
        lastFailed = false;
      }
    }
    
    //draw the character
    textSize(scale); 
    rectMode(RADIUS);
    text(new String(chars_uni), x, y + (scale/2.8f));
    
    //display the current codepoint
    textSize(14);
    text("U+" + intToUniHex(this_codepoint), x, y + scale*1.4f);
    
    //wrap it nice and neat
    fill(0, 0, 0, 0); 
    rect(x, y, scale/1.1f, scale/1.1f, 10);
  }
  
  //get ranges where current font stack does not have an associated character >>
  //this includes null/whitespace/blank characters that *shouldn't* have an associated character
  public void getBrokenRanges(){
    char[] cu_temp;
    Boolean lf_temp = false;
    ArrayList<Integer> fp_temp = new ArrayList<Integer>();
     
     //test for what's broken where, only record start and endpoints of broken ranges
     for(int j = 0; j < end_codepoint+1; j++){
       cu_temp = Character.toChars(j);
       if (default_font.getGlyph(cu_temp[0]) == null && !lf_temp){
          fp_temp.add(j);
          lf_temp = true;
       } else if(default_font.getGlyph(cu_temp[0]) != null && lf_temp){
          fp_temp.add(j);
          lf_temp = false;
       }
     }
     
     //print it all out
     for(int i = 0; i < fp_temp.size(); i++){
       String hexy = intToUniHex(fp_temp.get(i));
       if(i%2 == 0){
         print("[" + hexy + ", ");
       } else {
         print(hexy + "]\n");
       }
     }
  }
  
  //convert an int codepoint to a unicode hexadecimal point
  public String intToUniHex(int code){
    String unihex = Integer.toHexString(code);
    while(true){
      if (unihex.length() < 4) {
        unihex = "0" + unihex;
      } else {
        break;
      }
    }
    return unihex.toUpperCase();
  }
}
public class PopoutMenu{
  PVector center, dimens;
  String title;
  ArrayList<Button> menuButtons;
  
  int[] cols = new int[2]; //0 = background, 1 = outline & text
  
  int titleTextSize = 40;
  
  Boolean closed = true;
  int animationDur = 20;
  int animationState = 0;
  
  
  //initialize with title, cols, center of menu, dimentions, and the buttons to display
  public PopoutMenu(String title, int[] cols, PVector center, PVector dimens, ArrayList<Button> buttons){
    this.title = title;
    this.cols = cols;
    this.center = center;
    this.dimens = dimens;
    menuButtons = buttons;
  }
  
  //for bringing up and closing the menu
  public void toggleMenu(){
    closed = !closed;
    animationState = 0;
  }
  
  //if menu is open, animate & render it!
  public void renderMenu(){
    //translate(center.x-(dimens.x/2), center.y-(dimens.y/2));
    rectMode(CENTER);
    if(closed){
      return;
    }
    //temp dimensions to animate
    float dimx = dimens.x;
    float dimy = dimens.y;
    float fillAlpha = 255;
    
    if(animationState < animationDur){
      float halfway = animationDur/2;
      
      //first half of animation, pop in menu
      if(animationState < halfway){
        dimx *= animationState/halfway;
        dimy *= animationState/halfway;

        menuButtons.forEach((b) -> b.setOpacity(0));
        fillAlpha = 0;
        
      //second half of animation, fade in buttons
      } else {
        fillAlpha = 255 * (animationState-halfway)/halfway;
        menuButtons.forEach((b) -> b.setOpacity(255 * (animationState-halfway)/halfway));
      }
      
      animationState++;
    }
      
    //draw background & text, then draw buttons & reset drawing mode
    fill(cols[0]);
    stroke(cols[1]);
    
    rect(center.x, center.y, dimx, dimy, 20);
    
    fill(cols[1], fillAlpha);
    text(title, center.x, center.y-(dimens.y/2)+30);

    rectMode(CORNER);
    menuButtons.forEach((b) -> b.render());
  }
}
@FunctionalInterface
public interface SliderFunction {
  public void execute(Slider s, float pos); 
}

PVector mouse_pressed_position;
public void mousePressed(){
  mouse_pressed_position = new PVector(mouseX, mouseY);
}

public class Slider {
  PVector center, set_renderPos, last_renderPos, line_coordsL, line_coordsR;
  float min, max, slope, yincep, horiz, verti;
  String name;
  int[] cols = new int[2]; //base colour, click colour
  Boolean pressed_latch = false;
  SliderFunction func;
  
  //centerpoint, horizontal half distance, vertical half distance, name, starting pos [0, 1], and color pallete
  public Slider(PVector center, float horiz, float verti, String name, float pos, int[] cols, SliderFunction func){
    this.center = center;
    this.horiz = horiz;
    this.verti = verti;
    this.name = name;
    this.cols = cols;
    this.func = func;
    
    set_renderPos = new PVector(horiz*2*pos + (center.x - horiz), verti*2*pos + (center.y - verti));
    last_renderPos = new PVector();
    line_coordsL = new PVector(center.x-horiz, center.y+verti);
    line_coordsR = new PVector(center.x+horiz, center.y-verti);
    slope = (line_coordsL.y - line_coordsR.y) / (line_coordsL.x-line_coordsR.x);
    yincep = line_coordsL.y - slope * line_coordsL.x;
  }
  
  public void updatePos(float pos){
    set_renderPos = new PVector(horiz*2*pos + (center.x - horiz), verti*2*pos + (center.y - verti));
  }
  
  public void render(){
    manipulate();
    strokeWeight(3);
    
    line(line_coordsL.x, line_coordsL.y, line_coordsR.x, line_coordsR.y);
    circle(center.x-horiz, center.y+verti, 5);
    circle(center.x+horiz, center.y-verti, 5);
    
    circle(set_renderPos.x, set_renderPos.y, 10);
  }
  
  //handle ui interaction
  public void manipulate(){
    stroke(cols[1]);
    fill(background_colour);
    
    Boolean was_pressed = pressed_latch;
    
    if(mousePressed){
      PVector nearestPoint = distanceToLine(new PVector(mouseX, mouseY));
      
      if(dist(nearestPoint.x, nearestPoint.y, mouse_pressed_position.x, mouse_pressed_position.y) < 24){   
        pressed_latch = true;
      }
      
      if(pressed_latch){
        set_renderPos.x = nearestPoint.x;
        set_renderPos.y = nearestPoint.y;
        
        last_renderPos.x = nearestPoint.x;
        last_renderPos.y = nearestPoint.y;
        
        stroke(cols[0]);
        fill(cols[0]);
      }
    } else {
      pressed_latch = false;
    }
    
    if(was_pressed && !pressed_latch){
      set_renderPos.x = last_renderPos.x;
      set_renderPos.y = last_renderPos.y;
      
      func.execute(this, this.getPos());
    }
    
  }
  
  //returns nearest point from input point to this slider line
  public PVector distanceToLine(PVector point_coords){    
    //modified from solub's (processing forum user) js vector version
    PVector d1 = PVector.sub(line_coordsR, line_coordsL);
    PVector d2 = PVector.sub(point_coords, line_coordsL);
    float l1 = d1.mag();
  
    float dotp = constrain(d2.dot(d1.normalize()), 0, l1);
      
    return PVector.add(line_coordsL, d1.mult(dotp));
  }
  
  public float getPos(){
    float percx = (set_renderPos.x - line_coordsL.x) / (horiz*2);
    float percy = (set_renderPos.y - line_coordsL.y) / (verti*2);
    
    if(Float.isNaN(percx)){
      percx = 0;
    } else if(Float.isNaN(percy)){
      percy = 0;
    }
    
    float percies = percx+percy;
    return percies;
  }
}
//processing video library throws errors on archlinux systems
//  >> problem with dual dependancy on libsoup 2 & 3
//     for now, no video implementation. maybe eventually
//      > will need to document how to resolve on archlinux systems in git page
//import processing.video.*;
//Movie movie;



//second processing window --> like an entire sub-sketch
public class DisplayFrame extends PApplet {
  Minim minim;
  Track track_controller;

  public void settings() {
    size(PApplet.parseInt(default_scale.y/2), PApplet.parseInt(default_scale.x/2));
  }

  public void setup() {
    minim = new Minim(this);
    surface.setTitle("display");
    track_controller = new Track();
    surface.setLocation(PApplet.parseInt(displayWidth-default_scale.y/2) - 50, 100);
  }

  public void draw() {
    background(background_colour);

    track_controller.displayMetadata();
    track_controller.loadTrack();
  }

  public void exit() {
    systemControlButtons.set(5, spawn_window);
    dispose();
    sa = null;
  }

  public void playButton() {
    track_controller.pauseResume();
  }

  public void restartAudioVideo() {
    track_controller.restartAudio();
  }

  public void fastforward(int milli) {
    track_controller.fastforward(milli);
  }

  public Boolean getIsPlaying() {
    return track_controller.tuneIsPlaying();
  }

  public int getTimeMillis() {
    if (track_controller == null) {
      track_controller = new Track();
    }
    return track_controller.getTimestamp();
  }

  public void setTime(int milli) {
    if (track_controller != null) {
      track_controller.setTimestamp(milli);
    }
  }

  public float getTime() {
    if (track_controller != null) {
      return track_controller.getDuration();
    }
    return 0;
  }

  public void setVol(float vol) {
    if (track_controller != null) {
      track_controller.setVol(vol);
    }
  }
  
  public String getMeta(int i){
    if (track_controller != null){
      return track_controller.getMetaData(i);
    }
    return "";
  }

  public class Track {
    //WaveformRenderer waveform; --> on the minim addListener() documentation, this is a custom class. maybe implement for polish later!
    AudioPlayer tune;
    AudioMetaData tune_meta;

    public Track() {
      loadTrack();
    }

    public void restartAudio() {
      if (tune != null) {
        tune.cue(0);
      }
    }

    public void fastforward(int milli) {
      if (tune != null) {
        tune.skip(milli);
      }
    }

    public void setTimestamp(int milli) {
      if (tune != null) {
        tune.cue(milli);
      }
    }

    public void setVol(float vol) {
      if (tune != null) {
        tune.shiftVolume(vol, tune.getVolume(), 500);
        tune.shiftGain(tune.getGain(), vol*100-50, 500);
        println("vol=" + vol);
      }
    }

    public void displayMetadata() {
      if (tune == null) {
        return;
      }

      fill(ui_highlight);

      textSize(15);
      text(tune_meta.fileName(), 10, 20);

      textSize(40);
      text(tune_meta.title(), 30, 70);
      textSize(30);
      text("by " + tune_meta.author(), 45, 110);

      textSize(20);
      text("on the album \"" + tune_meta.album() + "\"", 60, 145);

      textSize(70);
      text("duration:  ~" + getFormatedTimecode(tune_meta.length(), true, ':', false, ' '), 45, 260);
    }

    //0 outputs title, 1 outputs author
    public String getMetaData(int i){
      if (tune == null){
        return "";
      } else if (i == 0){
        return tune_meta.title();
      } else if (i == 1){
        return tune_meta.author();
      }
      return "";
    }

    public int getDuration() {
      if (tune != null && tune_meta != null) {
        return tune_meta.length();
      }
      return 1;
    }

    public void loadTrack() {
      if (tune == null && track != null) {
        tune = minim.loadFile(track.getAbsolutePath());
        tune_meta = tune.getMetaData();
      }
    }

    public void pauseResume() {
      if (tune != null) {
        if (tune.isPlaying()) {
          tune.pause();
        } else {
          tune.play();
        }
      }
    }

    public Boolean tuneIsPlaying() {
      if (tune != null) {
        return tune.isPlaying();
      }
      return false;
    }

    public int getTimestamp() {
      if (tune != null) {
        return tune.position();
      }
      return 0;
    }
  }
}
/* store transcript as a string array trans
display it >> account for scrolling. scroll using scroll wheel dynamically. 
'jump to next/prev line' in display
link text to vertical timeline >> variable spacing on timeline based on a slider/adjustment bar like in kdenlive
let you click on spots on vertical timeline to jump to position on scroll
dot indicators for where text appears in the vertical scroll --> if two texts would overlap, low opacity the further away text is from current pos
hotkey to advance lyric and record a position, hotkey to go back to last lyric AND unbind its position

allow when music is paused click & drag of lyric positions within the rang of prev & following lyric
*/

public class Transcript{
  char last_key; // remember last key pressed, for hotkey behavior
  int last_millis = 0; // remember time of hotkey press, for hotkey behavior
  int hotkey_millis_delay = 800; // delay between pressing the hotkey and triggering mode 2
  
  // this could be implemented better via an arraylist of tuples
  ArrayList<String> trans = new ArrayList<String>(); // the transcript
  ArrayList<Integer> times = new ArrayList<Integer>(); // the corresponding times for each line --> initialized as 0
  ArrayList<Boolean> toggles = new ArrayList<Boolean>(); // and the toggles for enabled/disabled lines --> initialized as true
  
  Boolean is_offscreen = false; // current line is offscreen = true
  int current_line; // index in trans of the currently selected line
  int line_spacing = 35; // spacing between lines, also used in other positionings on the screen
  float time_width = textWidth("0:00:00"); // because we need this regularly :p
  int timestamp = 0;
  
  float scroll = line_spacing*3; // the initial position of text on screen
  float scroll_speed = 13.4f; // scroll multiplier
  
  int trans_size = 20; // size of the text in the transcript
  int default_text_color = ui_active; // the default colour of the tex
  int highlight_text_color = ui_highlight; // the colour of the selected line
  
  public Transcript(String[] trans){
    this.trans = new ArrayList(Arrays.asList(trans));
    this.trans.add(0, "");
    this.trans.add("");
    
    this.trans.forEach(t -> {times.add(0); toggles.add(true);}); // fill out times/toggles so we can keep the arraylists synced
  }
  
  //display this transcript, then listen for all transcript-based hotkeys
  public void update(){
    if(track != null && sa != null){
      timestamp = sa.getTimeMillis();
    }
    
    display();
    
    // nextline [enter]
    if(hotkey(ENTER, 1, false)){
      current_line++;
      
      times.set(current_line-1, timestamp);
      
      offscreenOffset();
      
      if(current_line > trans.size()-1){
        current_line = trans.size()-1;
      } 
    }
    
    // prevline [backspace]
    else if (hotkey(BACKSPACE, 1, false)){
      times.set(current_line, 0);
      current_line--;
      
      if(current_line < 0){
        current_line = 0;
      }
      
      if(track != null && sa != null){
        sa.setTime(times.get(current_line));
      }
      
    } 
    
    // insert blank [tab]
    else if (hotkey(TAB, 0, false)){    
      current_line++;
      trans.add(current_line, "");
      times.add(current_line, millis());
      toggles.add(current_line, true);
    } 
    
    // [t]oggle line enabling
    else if (hotkey('t', 0, false)){
      toggles.set(current_line, !toggles.get(current_line));
    }
    
    // [delete] blank line
    else if (hotkey(DELETE, 0, false)){
      if(trans.get(current_line) == ""){
        trans.remove(current_line);
        toggles.remove(current_line);
        times.remove(current_line);
        current_line--;;
        
        if(current_line < 0){
          current_line = 0;
        }
      }
    }
      
    // [space] play/pause audio 
    else if (hotkey(' ', 0, false)){
      pauseButton.execute();
    }
    
    // [r]estart track
    else if (hotkey('r', 0, false)){
      restartButton.execute();
    }
    
    // rewind & fast farward
    else if (key == CODED){
      
      // [right arrow] fast forward
      if (keyCode == RIGHT && hotkey('\u0001', 2, true)){
        ffButton.execute();
      }
      
      // [left arrow] rewind
      if(keyCode == LEFT && hotkey('\u0000', 2, true)){
        reverseButton.execute();
      }
    }
    
    if(scroll > line_spacing*(3+current_line)){
      scroll = line_spacing*(3+current_line);
    }
  }
  
  /* sets the display parameters
  and then draws the transcript! */
  public void display(){
    textSize(trans_size);
    
    drawVisibleLines(default_text_color);
    drawCurrentLine(highlight_text_color);

    fill(background_colour);
    stroke(0, 0, 0, 0);
    rect(0, 0, width, 50);
  }
  
  //draws lines within the window
  public void drawVisibleLines(int line_colour){
    int this_line_colour;
    float linePos;
    
    for(int i = 0; i < trans.size(); i++){
      linePos = (i-current_line) * line_spacing + scroll;
      //stop looping if we're drawing past the bottom of the screen!
      if(linePos > height){
        break;
      } 
      
      //draw all non-current characters within the top of the window
      else if (linePos > 0 && i != current_line){
        
        if(!toggles.get(i)){
          this_line_colour = color(line_colour, 70);
        } else {
          this_line_colour = line_colour;
        }
        fill(this_line_colour);
        text(trans.get(i), width/2, linePos);
        
        stroke(0, 0, 0, 0);
        fill(background_colour);
        rect(line_spacing*1.5f-time_width/2 - 10, linePos+10-line_spacing, time_width + 20, 36);
        
        fill(this_line_colour);
        stroke(this_line_colour);
        text(getFormatedTimecode(times.get(i), true, ':', false, '.'), line_spacing*1.3f, linePos);
        
        if(i < current_line){
          strokeWeight(5);
          stroke(color (this_line_colour, 70));
          line(line_spacing+time_width, linePos - trans_size/3, width/2 - textWidth(trans.get(i))/2 - 10, linePos - trans_size/4);
          strokeWeight(4);
          
          if(trans.get(i) == ""){
            text("●", width/2, linePos);
          }
        }
      }
    }
  }
  
  //draws current line, handles off-screen behavior
  public void drawCurrentLine(int line_colour){
    is_offscreen = true;
    String cur_line = trans.get(current_line);
    String thisTime = getFormatedTimecode(timestamp, true, ':', true, '.').substring(0, 10);
    float currentPos = scroll - line_spacing;
    float txt_width = textWidth(cur_line);
    float time_width = textWidth(thisTime);
    
    if(currentPos <= line_spacing*2){
      currentPos = line_spacing*2;
    } else if (currentPos >= height-line_spacing*2){
      currentPos = height-line_spacing*2;
    } else {
      is_offscreen = false;
    }
    
    if(!toggles.get(current_line)){
      line_colour = color(line_colour, 100);
    }
    
    stroke(line_colour);
    fill(background_colour);
    rect(width/2 - txt_width/2 - 10, currentPos+10, txt_width + 20, 36);
    rect(line_spacing*1.5f-time_width/2 - 10, currentPos+10, time_width + 20, 36);
    
    fill(line_colour);
    text(cur_line, width/2, currentPos+line_spacing);
    text(thisTime, line_spacing*1.5f, currentPos+line_spacing);
  }
  
  //when is offscreen, this will offset autoscrolling. called in hotkey funcs
  public void offscreenOffset(){
    if(is_offscreen){
      scroll += line_spacing;
    }
  }
  
  /* returns true if input char = just pressed char. held down char activates only once.
  'mode' changes this behavior 
    --> 0 = one output per press; 1 = wait before repeat output; 2 = one output per frame
  if a char A is held, and the char B = hot, then func will return true. 
  if after pressing B, A remains held, future presses of B will return false. This is a bug. */
  public Boolean hotkey(char hot, int mode, Boolean forceRun){ 
    //in modes 1 & 2, higher val here = slower output there
    int slow_val = 3;
    
    //check if any key is pressed
    if(!keyPressed){
      last_key = '\u0000';
      return false;
    } 
    
    //correct key?
    if(key != hot && !forceRun){
      return false;
    }
    
    //if the key is being held, mode behavior
    if(key == last_key){
      int mils = millis();
      
      if(mode == 0){ return false; } 
      
      //if not enough time between initial and present press, mills%slow to slow down output
      if(mode == 1 && (last_millis + hotkey_millis_delay > mils || mils % slow_val != 0)){ return false; }
      
      //the mills%slow part just slows down mode 2's rate of output
      if(mode == 2 && mils % slow_val != 0){ return false; }
      
    } else {
      last_millis = millis();
    }
    
    last_key = hot;
    return true;
  }
  
  //basic scroll behavior
  public void scroll_page(int sc){
    scroll -= sc*scroll_speed;
    
    if(scroll > line_spacing*(3+current_line)){
      scroll = line_spacing*(3+current_line);
    }
  }
  
  //in the name, it resets transcript position without reseting programmed values
  public void resetTranscript(){
    scroll = line_spacing*3;
    current_line = 0;
  }
  
  //called to save transcript to a file, based on user filetype selection
  //formats: lrc, srt, sbv, mpsub, cap, smi, sami, vtt, ttml, dfxp, scc, stl, tds, cin, asc, ass, ssa, txt
  //          1    1    1     0     0    1    1     1     0     0    0    0    0    0    0    0    0    1
  public void saveTranscript(){
    //if nowhere to output
    if(outputDirectory == null){
      println("invalid or null output directory!");
      return;
    }
    
    println("Sending to file...");
    ArrayList<String> trans_final = new ArrayList<String>();
    switch(outputExtention){
      case ".lrc":
        trans_final = format_lrc();
        break;
      case ".srt":
        trans_final = format_srt();
        break;
      case ".sbv":
        trans_final = format_sbv();
        break;
      case ".smi":
        trans_final = format_sami();
        break;
      case ".sami":
        trans_final = format_sami();
        break;
      case ".vtt":
        trans_final = format_vtt();
        break;
      case ".txt":
        trans_final = format_txt();
        break;
      case "":
        trans_final = format_txt();
        break;
      default:
        trans_final = format_txt();
        break;
    }
    
    trans_final.forEach((l) -> println(l));
    saveTransToFile(trans_final);
  }
  
  public void saveTransToFile(ArrayList<String> transie){
    try{
      String fileNamePath = outputDirectory.getAbsolutePath() + "/" + transcript.getName().replaceFirst("[.][^.]+$", "") + "_sync" + outputExtention;
      File myObj = new File(fileNamePath);
      println(myObj.getAbsolutePath());
      if (myObj.createNewFile()) {
        System.out.println("File created: " + myObj.getName());
        try {
          FileWriter myWriter = new FileWriter(fileNamePath);
          
          for(int i = 0; i < transie.size(); i++){
            myWriter.write(transie.get(i)+"\n");
          }
          myWriter.close();
          System.out.println("Successfully wrote modified transcript to file!");
        } catch (IOException e) {
          System.out.println("Unexpected error occurred while writing to file");
          e.printStackTrace();
        }
        
      } else {
        System.out.println("An unexpected exporting occured. File already exists? Data will not be overwritten.");
      }
    } catch (IOException e){
      System.out.println("Unexpected error occured during file creation");
      e.printStackTrace();
    }
  }
  
  //format the transcript info into lrc style
  public ArrayList<String> format_lrc(){
    ArrayList<String> lrc = new ArrayList<String>();
    
    if(sa != null){
      lrc.add("[ti:" + sa.getMeta(0) + "]");
      lrc.add(" [ar:" + sa.getMeta(1) + "]");
    }
    for(int i = 0; i < trans.size(); i++){
      if(toggles.get(i)){
        lrc.add(getFormatedTimecode(times.get(i), false, ':', true, '.') + " " + trans.get(i));
      }
    }
    
    return lrc;
  }
  
  //format the transcript to srt
  public ArrayList<String> format_srt(){
    ArrayList<String>lrc = new ArrayList<String>();
    int count = 1;
    
    if(sa != null){
      times.add(PApplet.parseInt(sa.getTime()));
    } else {
      times.add(0);
    }
    
    for(int i = 0; i < trans.size(); i++){
      if(toggles.get(i)){
        lrc.add(str(count));
        lrc.add(getFormatedTimecode(times.get(i), true, ':', true, ',') + " --> " + 
                getFormatedTimecode(times.get(i+1), true, ':', true, ','));
        
        lrc.add(trans.get(i));
        lrc.add("");
        count++;
      }
    }
    
    return lrc;
  }
  
  //format the transcript to sbv 
  public ArrayList<String> format_sbv(){
    ArrayList<String>lrc = new ArrayList<String>();
    
    if(sa != null){
      times.add(PApplet.parseInt(sa.getTime()));
    } else {
      times.add(0);
    }
    
    for(int i = 0; i < trans.size(); i++){
      if(toggles.get(i)){
        lrc.add(getFormatedTimecode(times.get(i), true, ':', true, '.').substring(1) + "," + 
                getFormatedTimecode(times.get(i+1), true, ':', true, '.').substring(1));
        
        lrc.add(trans.get(i));
        lrc.add("");
      }
    }
    
    return lrc;
  }
  
  public ArrayList<String> format_vtt(){
    ArrayList<String>lrc = new ArrayList<String>(Arrays.asList(
    "WEBVTT",
    "STYLE",
    "::cue {",
    "    font-family: Arial;",
    "    color: fff;",
    "}"
    ));
    
    int count = 1;
    
    if(sa != null){
      times.add(PApplet.parseInt(sa.getTime()));
    } else {
      times.add(0);
    }

    for(int i = 0; i < trans.size(); i++){
      if(toggles.get(i)){
        lrc.add(str(count));
        lrc.add(getFormatedTimecode(times.get(i), true, ':', true, '.').substring(1) + " --> " + 
                getFormatedTimecode(times.get(i+1), true, ':', true, '.').substring(1));
        
        lrc.add(trans.get(i));
        lrc.add("");
        count++;
      }
    }   
 
    return lrc;
  }
  
  //TODO: lang coded into standard, so outputs will be labled as "english" even if not
  //lang selection ability for outputs? workarounds?
  public ArrayList<String> format_sami(){
    ArrayList<String>lrc = new ArrayList<String>(Arrays.asList(
    "<SAMI>",
    "",
    "<HEAD>",
    "<TITLE>SAMI Example</TITLE>",
    "",
    "<SAMIParam>",
    "  Media {cheap44.wav}",
    "  Metrics {time:ms;}",
    "  Spec {MSFT:1.0;}",
    "</SAMIParam>",
    "",
    "<STYLE TYPE=\"text/css\">",
    "<!--",
    "  P { font-family: Arial; font-weight: normal; color: white; background-color: black; text-align: center; }",
    "",
    "  #Source {color: red; background-color: blue; font-family: Courier; font-size: 12pt; font-weight: normal; text-align: left; }",
    "",
    "  .ENUSCC { name: English; lang: en-US ; SAMIType: CC ; }",//language denotation is inherent in the standard. currently the user cannot select language, so. this will do.
    "-->",
    "</STYLE>",
    "",
    "</HEAD>",
    "",
    "<BODY>",
    "",
    "<!-- Open play menu, choose Captions and Subtiles, On if available -->",
    "<!-- Open tools menu, Security, Show local captions when present -->",
    ""
    ));
    
    for(int i = 0; i < trans.size(); i++){
      if(toggles.get(i)){
        lrc.add("<SYNC Start=" + times.get(i) + ">");
        lrc.add("  <P Class=ENUSCC>" + trans.get(i) + "</P>");
        lrc.add("</SYNC>");
        lrc.add("");
      }
    }   
    
    lrc.add("</BODY>");
    lrc.add("</SAMI>");

    return lrc;
  }
  
  public ArrayList<String> format_txt(){
    ArrayList<String>lrc = new ArrayList<String>(Arrays.asList(
    "<<LYRICAL OUTPUT>>",
    "format: [toggled?] [millis] | text",
    "",
    "----------------------------------------------",
    ""
    ));
    
    for(int i = 0; i < trans.size(); i++){
      lrc.add("[" + toggles.get(i) + "] [" + times.get(i) + "] | " + trans.get(i));
    }   
    
    return lrc;
  }
}

public void mouseWheel(MouseEvent event){
  trans.scroll_page(event.getCount());
}


  public void settings() { size(900, 1400); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "main" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
